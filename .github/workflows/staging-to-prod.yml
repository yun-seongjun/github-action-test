name: Staging -> Main, Dev

on:
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

env:
  APPS: "neubie-go neubie-order neubie-order-admin"

jobs:
  staging-to-main-and-dev:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          fetch-tags: true
          token: ${{ github.token }}

      - name: Setup Node.js (22.17.1)
        uses: actions/setup-node@v4
        with:
          node-version: 22.17.1

      - name: Prepare head branch
        id: prep
        shell: bash
        run: |
          set -euo pipefail

          BASE_BRANCH="staging"
          HEAD_REF="$BASE_BRANCH"
          CHANGED_APPS=""

          # package.json ì˜ version ì½ê¸°
          get_version() {
          local pkg="$1"
          node -p "try{JSON.parse(require('fs').readFileSync('${pkg}','utf8')).version||''}catch(e){''}"
          }

         # x.y.z-rc.n -> x.y.z (ë§¤ì¹˜ ì•ˆ ë˜ë©´ ë¹ˆ ë¬¸ìžì—´)
          strip_rc() {
          local v="$1"
          printf '%s' "$v" | sed -nE 's/^([0-9]+\.[0-9]+\.[0-9]+)-rc\.[0-9]+$/\1.\2.\3/p'
         }

          for APP in ${{ env.APPS }}; do
          PKG="apps/$APP/package.json"
          [ -f "$PKG" ] || { echo "skip: $PKG not found" >&2; continue; }

          CUR=$(get_version "$PKG")
          [ -n "$CUR" ] || { echo "skip: $APP has empty version" >&2; continue; }

          NEW=$(strip_rc "$CUR")

          if [ -n "$NEW" ] && [ "$NEW" != "$CUR" ]; then
            node -e "
              const fs=require('fs'); const p='${PKG}';
              const pkg=JSON.parse(fs.readFileSync(p,'utf8'));
              pkg.version='${NEW}';
              fs.writeFileSync(p, JSON.stringify(pkg, null, 2)+'\n');
            "
            echo "write: $APP $CUR -> $NEW"
            CHANGED_APPS="$CHANGED_APPS $APP"
          else
            echo "keep:  $APP $CUR"
          fi
          done

          # apps/*/package.json ì— ë³€ê²½ì´ ìžˆëŠ” ê²½ìš°ì—ë§Œ ë¸Œëžœì¹˜ ìƒì„±
          if ! git diff --quiet -- apps/*/package.json 2>/dev/null; then
          git switch -c release/rc-to-stable 2>/dev/null || git switch release/rc-to-stable
          git config user.name  "GitHub Actions"
          git config user.email "github-actions@github.com"
          git add apps/*/package.json
          git commit -m "release: RC to stable"
          git push --force-with-lease origin HEAD:release/rc-to-stable
          HEAD_REF="release/rc-to-stable"
          fi

          echo "head=$HEAD_REF" >> "$GITHUB_OUTPUT"
          echo "changed_apps=$CHANGED_APPS" >> "$GITHUB_OUTPUT"

      - name: Build versions line
        id: ver
        shell: bash
        run: |
          set -euo pipefail

          CHANGED_APPS="${{ steps.prep.outputs.changed_apps }}"

          if [ -z "$CHANGED_APPS" ]; then
            echo "pretty=(no app versions found)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          PRETTY=""
          SEP=""

          for APP in $CHANGED_APPS; do
            PKG="apps/$APP/package.json"
            [ -f "$PKG" ] || continue
            V=$(node -p "JSON.parse(require('fs').readFileSync('${PKG}','utf8')).version||''")
            PRETTY="${PRETTY}${SEP}\`${APP}@${V}\`"
            SEP=", "
          done

          echo "pretty=$PRETTY" >> "$GITHUB_OUTPUT"

      - name: Delete ALL RC tags for changed apps
        if: steps.prep.outputs.rc_stripped == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          git fetch --tags --force --prune origin
          CHANGED_APPS="${{ steps.prep.outputs.changed_apps }}"
          [ -n "$CHANGED_APPS" ] || exit 0
          for APP in $CHANGED_APPS; do
            TAGS=$(git ls-remote --tags origin "${APP}@*-rc.*" "${APP}@v*-rc.*" \
              | awk '{print $2}' | sed 's@^refs/tags/@@')
            [ -n "$TAGS" ] || continue
            echo "Found RC tags for $APP:"
            printf '  %s\n' $TAGS
            for T in $TAGS; do
              ENC=$(printf '%s' "$T" | jq -sRr @uri)  # URL-encode '@', '.'
              echo "Deleting: $T"
              gh api -X DELETE "repos/${REPO}/git/refs/tags/${ENC}" || {
                echo "API delete failed for $T, fallback to git pushâ€¦"
                git push origin ":refs/tags/$T"
              }
            done
          done
          echo "Remaining RC tags (should be empty):"
          for APP in $CHANGED_APPS; do
            git ls-remote --tags origin "${APP}@*-rc.*" "${APP}@v*-rc.*" | awk '{print $2}' | sed 's@^refs/tags/@@' || true
          done

      - name: Open/ensure PR to main
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          HEAD="${{ steps.prep.outputs.head }}"
          git fetch origin main "$HEAD"
          if git diff --quiet origin/main origin/"$HEAD"; then
            echo "No diff between $HEAD and main; skipping PR."
            exit 0
          fi
          if gh pr list --base main --head "$HEAD" --json number -q '.[0].number' | grep -q '^[0-9]\+$'; then
            echo "PR already exists for head=$HEAD -> main; skipping create."
            exit 0
          fi
          printf -v LINE 'ðŸš€ Release: %s' '${{ steps.ver.outputs.pretty }}'
          gh pr create \
            --repo "${{ github.repository }}" \
            --base main \
            --head "$HEAD" \
            --title "$LINE" \
            --body  "$LINE"

      - name: Open/ensure PR to dev
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          HEAD="${{ steps.prep.outputs.head }}"
          git fetch origin dev "$HEAD"
          if git diff --quiet origin/dev origin/"$HEAD"; then
            echo "No diff between $HEAD and dev; skipping PR."
            exit 0
          fi
          if gh pr list --base dev --head "$HEAD" --json number -q '.[0].number' | grep -q '^[0-9]\+$'; then
            echo "PR already exists for head=$HEAD -> dev; skipping create."
            exit 0
          fi
          printf -v LINE 'ðŸ”€ Staging -> Dev: %s' '${{ steps.ver.outputs.pretty }}'
          gh pr create \
            --repo "${{ github.repository }}" \
            --base dev \
            --head "$HEAD" \
            --title "$LINE" \
            --body  "$LINE"
