name: Staging -> Main, Dev

on:
  workflow_dispatch: {}

permissions:
  contents: write
  pull-requests: write

env:
  APPS: "neubie-go neubie-order neubie-order-admin"

jobs:
  staging-to-main-and-dev:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout staging
        uses: actions/checkout@v4
        with:
          ref: staging
          fetch-depth: 0
          fetch-tags: true
          token: ${{ github.token }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22.17.1

      - name: Prepare head branch
        id: prep
        shell: bash
        run: |
          set -euo pipefail

          BASE_BRANCH="staging"
          HEAD_REF="$BASE_BRANCH"
          CHANGED_APPS=""

          # package.json ì—ì„œ version ì½ê¸°
          get_version() {
            local pkg="$1"
            node -p "try{JSON.parse(require('fs').readFileSync('${pkg}','utf8')).version||''}catch(e){''}"
          }

          # x.y.z-rc.n -> x.y.z ë¡œ ë³€í™˜ (ë§¤ì¹˜ ì•ˆ ë˜ë©´ ë¹ˆ ë¬¸ìžì—´)
          strip_rc() {
            local v="$1"
            printf '%s' "$v" | sed -nE 's/^([0-9]+)\.([0-9]+)\.([0-9]+)-rc\.[0-9]+$/\1.\2.\3/p'
          }

          echo "::group::Version scan (before)"
          for APP in ${{ env.APPS }}; do
            PACKAGE="apps/$APP/package.json"
            if [ ! -f "$PACKAGE" ]; then
              echo "skip: $PACKAGE not found" >&2
              continue
            fi
            CURRENT="$(get_version "$PACKAGE")"
            echo "before: $APP -> '$CURRENT'"
          done
          echo "::endgroup::"

          # package.json ì—ì„œ ì‹¤ì œë¡œ -rc.N ì œê±°
          for APP in ${{ env.APPS }}; do
            PACKAGE="apps/$APP/package.json"
            [ -f "$PACKAGE" ] || continue

            CURRENT="$(get_version "$PACKAGE")"
            [ -n "$CURRENT" ] || continue

            NEW="$(strip_rc "$CURRENT")"

            if [ -n "$NEW" ] && [ "$NEW" != "$CURRENT" ]; then
              node -e "
                const fs=require('fs'); const p='${PACKAGE}';
                const pkg=JSON.parse(fs.readFileSync(p,'utf8'));
                pkg.version='${NEW}';
                fs.writeFileSync(p, JSON.stringify(pkg, null, 2)+'\n');
              "
              echo "write: $APP $CURRENT -> $NEW"
              CHANGED_APPS="$CHANGED_APPS $APP"
            else
              echo "keep:  $APP $CURRENT"
            fi
          done

          # ë³€ê²½ì´ ìžˆìœ¼ë©´ release/rc-to-stable ë¸Œëžœì¹˜ ìƒì„±/ì—…ë°ì´íŠ¸
          if [ -n "$(git status --porcelain apps/*/package.json 2>/dev/null)" ]; then
            git switch -c release/rc-to-stable 2>/dev/null || git switch release/rc-to-stable
            git config user.name  "GitHub Actions"
            git config user.email "github-actions@github.com"
            git add apps/*/package.json
            git commit -m "release: RC to stable"
            git push --force-with-lease origin HEAD:release/rc-to-stable
            HEAD_REF="release/rc-to-stable"
          fi

          # ê³µë°± ì •ë¦¬
          CHANGED_APPS="$(echo "$CHANGED_APPS" | xargs || true)"

          echo "::group::Version scan (after)"
          for APP in ${{ env.APPS }}; do
            PACKAGE="apps/$APP/package.json"
            [ -f "$PACKAGE" ] || continue
            NOW="$(get_version "$PACKAGE")"
            echo "after:  $APP -> '$NOW'"
          done
          echo "::endgroup::"

          echo "head=$HEAD_REF" >> "$GITHUB_OUTPUT"
          echo "changed_apps=$CHANGED_APPS" >> "$GITHUB_OUTPUT"

          # RC ì œê±° ì—¬ë¶€ ì¶œë ¥ (íƒœê·¸ ì‚­ì œ step ì¡°ê±´ìš©)
          if [ -n "$CHANGED_APPS" ]; then
            echo "rc_stripped=true" >> "$GITHUB_OUTPUT"
          else
            echo "rc_stripped=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Build versions line
        id: ver
        shell: bash
        run: |
          set -euo pipefail

          CHANGED_APPS="${{ steps.prep.outputs.changed_apps }}"

          if [ -z "$CHANGED_APPS" ]; then
            echo "pretty=(no app versions found)" >> "$GITHUB_OUTPUT"
            echo "title_short=(no app versions found)" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          VERSIONS_MARKDOWN=""
          DELIMITER=""

          FIRST_APP=""
          FIRST_VERSION=""
          COUNT=0

          # ì „ì²´ ëª©ë¡ ìƒì„± + ì²« ì•±/ë²„ì „ ì €ìž¥
          for APP in $CHANGED_APPS; do
            PACKAGE="apps/$APP/package.json"
            [ -f "$PACKAGE" ] || continue

            VERSION="$(node -p "JSON.parse(require('fs').readFileSync('${PACKAGE}','utf8')).version||''")"

            VERSIONS_MARKDOWN="${VERSIONS_MARKDOWN}${DELIMITER}\`${APP}@${VERSION}\`"
            DELIMITER=", "

            COUNT=$((COUNT+1))

            if [ -z "$FIRST_APP" ]; then
              FIRST_APP="$APP"
              FIRST_VERSION="$VERSION"
            fi
          done

          # ì œëª©ìš©: ì²« ì•± + ë²„ì „ + ë‚˜ë¨¸ì§€ ê°œìˆ˜
          if [ "$COUNT" -eq 1 ]; then
            TITLE_SHORT="\`${FIRST_APP}@${FIRST_VERSION}\`"
          else
            REMAIN=$((COUNT - 1))
            TITLE_SHORT="\`${FIRST_APP}@${FIRST_VERSION}\` ì™¸ ${REMAIN}ê°œ"
          fi

          echo "pretty=$VERSIONS_MARKDOWN" >> "$GITHUB_OUTPUT"
          echo "title_short=$TITLE_SHORT" >> "$GITHUB_OUTPUT"

      - name: Delete ALL RC tags for changed apps
        if: steps.prep.outputs.rc_stripped == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          git fetch --tags --force --prune origin

          CHANGED_APPS="${{ steps.prep.outputs.changed_apps }}"
          [ -n "$CHANGED_APPS" ] || exit 0

          for APP in $CHANGED_APPS; do
            TAGS="$(git ls-remote --tags origin "${APP}@*-rc.*" "${APP}@v*-rc.*" \
              | awk '{print $2}' | sed 's@^refs/tags/@@')"

            [ -n "$TAGS" ] || continue

            echo "Found RC tags for $APP:"
            printf '  %s\n' $TAGS

            for T in $TAGS; do
              ENC="$(printf '%s' "$T" | jq -sRr @uri)"  # URL-encode '@', '.'
              echo "Deleting: $T"
              if ! gh api -X DELETE "repos/${REPO}/git/refs/tags/${ENC}"; then
                echo "API delete failed for $T, fallback to git pushâ€¦"
                git push origin ":refs/tags/$T"
              fi
            done
          done

          echo "Remaining RC tags (should be empty):"
          for APP in $CHANGED_APPS; do
            git ls-remote --tags origin "${APP}@*-rc.*" "${APP}@v*-rc.*" \
              | awk '{print $2}' | sed 's@^refs/tags/@@' || true
          done

      - name: Create PR to main & dev
        shell: bash
        env:
          GH_TOKEN: ${{ github.token }}
          HEAD_REF: ${{ steps.prep.outputs.head }}
          TITLE_SHORT: ${{ steps.ver.outputs.title_short }}
          VERSIONS_PRETTY: ${{ steps.ver.outputs.pretty }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail

          # ê³µìš© í•¨ìˆ˜: base ë¸Œëžœì¹˜ í•˜ë‚˜ì— ëŒ€í•´ PR ìƒì„±
          create_pr() {
            local BASE_BRANCH="$1"
            local TITLE_PREFIX="$2"

            echo ""
            echo "=== Processing base=$BASE_BRANCH, head=$HEAD_REF ==="

            # base, head ë‘˜ ë‹¤ fetch
            git fetch origin "$BASE_BRANCH" "$HEAD_REF"

            # diff ì—†ìœ¼ë©´ PR ìƒì„± ì•ˆ í•¨
            if git diff --quiet "origin/$BASE_BRANCH" "origin/$HEAD_REF"; then
              echo "No diff between $HEAD_REF and $BASE_BRANCH; skipping PR."
              return
            fi

            # ê°™ì€ head/base ì¡°í•© PR ì´ë¯¸ ìžˆìœ¼ë©´ ìƒì„± ì•ˆ í•¨
            if gh pr list --repo "$REPO" --base "$BASE_BRANCH" --head "$HEAD_REF" \
              --json number -q '.[0].number' | grep -q '^[0-9]\+$'; then
              echo "PR already exists for head=$HEAD_REF -> $BASE_BRANCH; skipping create."
              return
            fi

            local TITLE BODY
            printf -v TITLE '%s %s' "$TITLE_PREFIX" "$TITLE_SHORT"
            printf -v BODY  '%s %s' "$TITLE_PREFIX" "$VERSIONS_PRETTY"

            echo "Creating PR: $TITLE"

            gh pr create \
              --repo "$REPO" \
              --base "$BASE_BRANCH" \
              --head "$HEAD_REF" \
              --title "$TITLE" \
              --body  "$BODY"
          }

          # mainìš©
          create_pr "main" "ðŸš€ Release:"

          # devìš©
          create_pr "dev" "ðŸ”€ Staging -> Dev:"
