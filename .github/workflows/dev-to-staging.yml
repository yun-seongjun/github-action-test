name: Dev -> Staging

on:
  workflow_dispatch:
    inputs:
      new_level:
        description: "ì—…ë°ì´íŠ¸ í•  ë²„ì „ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”"
        type: choice
        required: true
        default: minor
        options:
          - patch
          - minor
          - major
      apps:
        description: "ì ìš©í•  ì•±ì„ ì„ íƒí•˜ì„¸ìš”"
        type: choice
        required: true
        default: auto
        options:
          - auto
          - neubie-go
          - neubie-order
          - neubie-order-admin

permissions:
  contents: write

env:
  APPS: "neubie-go neubie-order neubie-order-admin"

jobs:
  create-staging:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "GitHub Actions"
          git config user.email "github-actions@github.com"

      - name: Recreate clean staging branch from dev
        shell: bash
        run: |
          # ì—ëŸ¬ë°œìƒ, ì„ ì–¸ë˜ì§€ì•Šì€ ë³€ìˆ˜ì‚¬ìš©, íŒŒì´í”„ ì¤‘ê°„ì˜ ì˜¤ë¥˜ ë°œìƒì‹œ ë©ˆì¶¤ (exit code ì—†ì–´ë„ ë©ˆì¶¤)
          set -euo pipefail

          # origin/dev ìµœì‹  ê°€ì ¸ì˜¤ê¸°
          git fetch origin dev

          # ë¡œì»¬ staging ë¸Œëœì¹˜ë¥¼ origin/dev ê¸°ì¤€ìœ¼ë¡œ ë§ì¶”ê¸°
          git checkout -B staging origin/dev

          # ì›ê²© staging ë¸Œëœì¹˜ ì‚­ì œ
          # :staging > ë¹ˆê°’ì„ stagingìœ¼ë¡œ (ë¹ˆ refspecì€ ëŒ€ìƒ ref ì‚­ì œ)
          git push origin :staging

      - name: Resolve target apps from changes
        id: diff
        shell: bash
        env:
          TARGET_APP: ${{ inputs.apps }}
        run: |
          set -euo pipefail

          # main ìµœì‹  ê°€ì ¸ì˜¤ê¸° (devì™€ ë³€ê²½ì  ì²´í¬ìœ„í•´)
          git fetch origin main

          TARGETS=""

          if [[ "$TARGET_APP" == "auto" ]]; then
            TARGETAPPS=""
            CHANGED_FILES=$(git diff --name-only origin/main..HEAD)

            for FILE in $CHANGED_FILES; do
              # apps/*/* íŒ¨í„´ í•„í„°ë§
              if [[ "$FILE" == apps/*/* ]]; then
                # "apps/" ì œê±° (${ë³€ìˆ˜#íŒ¨í„´} ì€ ì•ì—ì„œë¶€í„° íŒ¨í„´ì— ë§¤ì¹­ë˜ëŠ” ë¶€ë¶„ ì œê±°)
                APP="${FILE#apps/}"
                # ì²« "/" ì´í›„ ì œê±° (${ë³€ìˆ˜%%íŒ¨í„´} ì€ ë’¤ì—ì„œë¶€í„° ë§¤ì¹­ë˜ëŠ”ê²ƒ ì œê±°)
                APP="${APP%%/*}"
                TARGETAPPS="$TARGETAPPS $APP"
              fi
            done

            # "$TARGETAPPS" ê³µë°± ê¸°ì¤€ìœ¼ë¡œ ìª¼ê°œê¸° > ì •ë ¬ ë° ì¤‘ë³µ ì œê±° > í•œì¤„ ê³µë°± êµ¬ë¶„ ë¬¸ìì—´ ë³€í™˜
            TARGETS="$(echo "$TARGETAPPS" | xargs -n1 | sort -u | xargs)"
          else
            TARGETS="$TARGET_APP"
          fi

          # "apps=$TARGETS" ë¬¸ìì—´ ìƒì„±í•˜ì—¬ "$GITHUB_OUTPUT" íŒŒì¼ ëì— ì¶”ê°€
          echo "apps=$TARGETS" >> "$GITHUB_OUTPUT"

      - name: Update app package versions to next RC
        if: ${{ steps.diff.outputs.apps != '' }}
        # bash ë¬¸ë²• ì‚¬ìš©í•˜ê³ ìˆì–´ ëŸ¬ë„ˆ ë³€ê²½ ëŒ€ë¹„
        shell: bash
        env:
          NEW_LEVEL: ${{ inputs.new_level }}
        run: |
          set -euo pipefail

          APPS="${{ steps.diff.outputs.apps }}"

          # ë²„ì „ ë³€ê²½ í•¨ìˆ˜ (í•˜ë‹¨ ë°˜ë³µë¬¸ì—ì„œ ì‚¬ìš©)
          new_version () {
            # í•¨ìˆ˜ì—ì„œë§Œ ì“¸ ë³€ìˆ˜ ì„ ì–¸ ($1, $2ëŠ” ì²«ë²ˆì§¸ ì¸ì, ë‘ë²ˆì¨° ì¸ì)
            local VERSION="$1" LEVEL="$2" MAJOR MINOR PATCH
            # "."ìœ¼ë¡œ ë²„ì „ ë¶„ë¦¬ í›„ ê° ë³€ìˆ˜ì— í• ë‹¹ ( "<<<" ì€ ë¬¸ìì—´ í‘œì¤€ ì…ë ¥ )
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
            # ê°’ì´ ë¹„ì–´ìˆìœ¼ë©´ ê¸°ë³¸ê°’ 0 ì„¸íŒ…
            MAJOR=${MAJOR:-0}; MINOR=${MINOR:-0}; PATCH=${PATCH:-0}
            case "$LEVEL" in
              major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR+1)); PATCH=0 ;;
              patch|*) PATCH=$((PATCH+1)) ;;
            esac
            echo "${MAJOR}.${MINOR}.${PATCH}"
          }

          for APP in $APPS; do
            PACKAGE="apps/$APP/package.json"
            [ -f "$PACKAGE" ] || continue

            # í˜„ì¬ ë²„ì „ base version ê°€ì ¸ì˜¤ê¸°
            BASE=$(node -p "require('./$PACKAGE').version")
            # new_version í•¨ìˆ˜ë¥¼ ì²«ë²ˆì¨° ì¸ìì™€ ë‘ë²ˆì¨° ì¸ì í¬í•¨í•˜ì—¬ ì‹¤í–‰
            NEW_BASE=$(new_version "$BASE" "$NEW_LEVEL")

            # dev to stagingì€ ë²„ì „ë‹¹ í•œ ë²ˆë§Œì´ë¼ê³  ê°€ì • â†’ í•­ìƒ rc.1
            NEW="${NEW_BASE}-rc.1"

            # package.json version ê°±ì‹ 
            node -e "
              const fs = require('fs');
              const path = '$PACKAGE';
              const package = JSON.parse(fs.readFileSync(path, 'utf8'));
              package.version = '$NEW';
              fs.writeFileSync(path, JSON.stringify(package, null, 2) + '\n');
            "

            git add "$PACKAGE"
            git commit -m "ğŸš€ [$APP] ${BASE} â†’ ${NEW}"
          done

      - name: Push staging branch
        run: |
          git push -u origin HEAD:staging
