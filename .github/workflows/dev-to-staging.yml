name: Dev -> Staging

on:
  workflow_dispatch:
    inputs:
      bump_level:
        description: "Version bump"
        type: choice
        required: true
        default: patch
        options:
          - patch
          - minor
          - major
      apps:
        description: "Target app"
        type: choice
        required: true
        default: auto
        options:
          - auto
          - neubie-go
          - neubie-order
          - neubie-order-admin

permissions:
  contents: write

env:
  APPS: "neubie-go neubie-order neubie-order-admin"

jobs:
  create-staging:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: dev
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name  "GitHub Actions"
          git config user.email "github-actions@github.com"

      - name: Prepare staging branch
        shell: bash
        run: |
          set -euo pipefail

          # origin/dev 최신 가져오기
          git fetch origin dev

          # 로컬 staging 브랜치를 origin/dev 기준으로 강제로 맞추기
          git checkout -B staging origin/dev

          # 원격 staging 브랜치 삭제
          git push origin :staging 2>/dev/null || true

      - name: Resolve target apps
        id: diff
        shell: bash
        env:
          INPUT_APPS: ${{ inputs.apps }}
        run: |
          set -euo pipefail

          CATALOG="${{ env.APPS }}"

          # main 최신 가져오기 (dev와 변경점 체크위해)
          git fetch origin main >/dev/null 2>&1 || true

          TARGETAPPS="$INPUT_APPS"

          if [ "$INPUT_APPS" = "auto" ]; then
          # 경로가 "apps/" 로 시작하면서 "/" 기준 2번째 가져오기
          TARGETAPPS=$(git diff --name-only origin/main..HEAD 2>/dev/null \
          | awk -F/ '/^apps\//{print $2}' || true)
          fi

          TARGETS=""

          for app in $CATALOG; do
          # TARGETAPPS에 app 포함여부 확인
          if printf '%s\n' $TARGETAPPS | grep -qx -- "$app"; then
          # TARGETS가 빈값이면 "app", 비어있지 않으면 "기존값 + 공백 + app"
          TARGETS="${TARGETS:+$TARGETS }$app"
          fi
          done

          echo "apps=$TARGETS"
          echo "apps=$TARGETS" >> "$GITHUB_OUTPUT"

      - name: Compute next RC and bump
        if: ${{ steps.diff.outputs.apps != '' }}
        id: bump
        shell: bash
        env:
          BUMP_LEVEL: ${{ inputs.bump_level }}
        run: |
          set -euo pipefail

          APPS="${{ steps.diff.outputs.apps }}"

          # 비어 있으면 종료
          if [ -z "$APPS" ]; then
            echo "empty apps" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # 버전 변경 함수 (하단 반복문에서 사용)
          bump_version () {
            local VER="$1" LVL="$2" MAJOR MINOR PATCH
            # "."으로 버전 분리
            IFS='.' read -r MAJOR MINOR PATCH <<< "$VER"
            # default 설정
            MAJOR=${MAJOR:-0}; MINOR=${MINOR:-0}; PATCH=${PATCH:-0}
            case "$LVL" in
              major) MAJOR=$((MAJOR+1)); MINOR=0; PATCH=0 ;;
              minor) MINOR=$((MINOR+1)); PATCH=0 ;;
              patch|*) PATCH=$((PATCH+1)) ;;
            esac
            echo "${MAJOR}.${MINOR}.${PATCH}"
          }

          for APP in $APPS; do
            # 버전 갱신을 위한 package.json
            PKG="apps/$APP/package.json"
            [ -f "$PKG" ] || continue

            # 현재 버전 base version 가져오기
            BASE=$(node -p "require('./$PKG').version")
            NEWBASE=$(bump_version "$BASE" "$BUMP_LEVEL")

            # dev to staging은 버전당 한 번만이라고 가정 → 항상 rc.1
            NEW="${NEWBASE}-rc.1"

            # package.json version 갱신
            node -e "
              const fs = require('fs');
              const p = '$PKG';
              const pkg = JSON.parse(fs.readFileSync(p, 'utf8'));
              pkg.version = '$NEW';
              fs.writeFileSync(p, JSON.stringify(pkg, null, 2) + '\n');
            "

            git add "$PKG"
            git commit -m "🚀 [$APP] ${BASE} → ${NEW}"
          done

      - name: Push staging branch
        run: |
          git push -u origin HEAD:staging
