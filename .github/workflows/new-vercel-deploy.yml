name: Deploy --new

on:
  workflow_dispatch:
    inputs:
      app:
        description: "Select app to be deployed"
        required: true
        default: "NEUBIE_GO"
        type: choice
        options:
          - NEUBIE_GO
          - NEUBIE_ORDER
          - NEUBIE_ORDER_ADMIN
      dry-run:
        description: "Simulate only (no vercel deploy / no QA trigger)"
        required: false
        type: boolean
        default: true

permissions:
  contents: read

# 같은 브랜치/같은 앱에 대한 동시 배포 방지
concurrency:
  group: deploy-${{ github.ref_name }}-${{ github.event.inputs.app }}
  cancel-in-progress: false

jobs:
  deploy:
    if: github.ref_name == 'main' || github.ref_name == 'staging'
    runs-on: ubuntu-latest
    env:
      DRY_RUN: ${{ github.event.inputs.dry-run && 'true' || 'false' }}
      VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
      VERCEL_PROJECT_ID: ${{ github.event.inputs.app == 'NEUBIE_GO' && secrets.VERCEL_PROJECT_ID_GO || github.event.inputs.app == 'NEUBIE_ORDER' && secrets.VERCEL_PROJECT_ID_ORDER || secrets.VERCEL_PROJECT_ID_ORDER_ADMIN }}

    steps:
      - name: DRY RUN notice
        run: |
          if [ "${{ env.DRY_RUN }}" = "true" ]; then
            echo "⚠️ DRY RUN MODE ENABLED: Vercel deploy & QA trigger will be simulated only."
          else
            echo "✅ LIVE MODE: This run will deploy to Vercel and trigger QA."
          fi

      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Preflight (secrets & node)
        shell: bash
        run: |
          set -euo pipefail
          for key in VERCEL_ORG_ID VERCEL_PROJECT_ID; do
            v="${!key:-}"
            if [ -z "$v" ]; then
              echo "::error ::Missing required env: $key"; exit 1
            fi
          done
          if [ -z "${{ secrets.VERCEL_TOKEN }}" ]; then
            echo "::error ::Missing secrets.VERCEL_TOKEN"; exit 1
          fi

      - name: Map app to path and pretty name
        id: map
        shell: bash
        run: |
          case "${{ github.event.inputs.app }}" in
            NEUBIE_GO)
              echo "dir=apps/neubie-go" >> "$GITHUB_OUTPUT"
              echo "name=뉴비고" >> "$GITHUB_OUTPUT"
              ;;
            NEUBIE_ORDER)
              echo "dir=apps/neubie-order" >> "$GITHUB_OUTPUT"
              echo "name=뉴비오더" >> "$GITHUB_OUTPUT"
              ;;
            NEUBIE_ORDER_ADMIN)
              echo "dir=apps/neubie-order-admin" >> "$GITHUB_OUTPUT"
              echo "name=뉴비오더 어드민" >> "$GITHUB_OUTPUT"
              ;;
          esac
          echo "APP_NAME=${{ steps.map.outputs.name }}" >> $GITHUB_ENV

      - name: Setup Node.js (22.17.1)
        uses: actions/setup-node@v4
        with:
          node-version: 22.17.1

      - name: Read version & enforce policy
        shell: bash
        run: |
          PKG="${{ steps.map.outputs.dir }}/package.json"
          if [ ! -f "$PKG" ]; then
            echo "::error ::package.json not found at $PKG"
            exit 1
          fi

          V=$(node -p "require('./'+process.argv[1]).version" "$PKG")
          echo "App: ${{ steps.map.outputs.name }}  |  Branch: ${{ github.ref_name }}  |  Version: $V"

          if [ "${{ github.ref_name }}" = "staging" ]; then
            echo "$V" | grep -qE "-rc\.[0-9]+$" || { echo "::error ::Staging needs RC (found $V)"; exit 1; }
          else # main
            echo "$V" | grep -qE "-rc\.[0-9]+$" && { echo "::error ::Main needs stable (found $V)"; exit 1; }
          fi
          echo "APP_VERSION=$V" >> $GITHUB_ENV

      - name: Install Vercel CLI
        if: env.DRY_RUN != 'true'
        run: npm i -g --no-fund --no-audit vercel@latest

      - name: Pull Vercel Environment Information (LIVE)
        if: env.DRY_RUN != 'true'
        working-directory: ${{ steps.map.outputs.dir }}
        run: |
          if [ "${{ github.ref_name }}" = "main" ]; then
            vercel pull --yes --environment=production --token=${{ secrets.VERCEL_TOKEN }}
          else
            vercel pull --yes --environment=preview --git-branch=staging --token=${{ secrets.VERCEL_TOKEN }}
          fi

      - name: Pull Vercel Environment Information (DRY RUN)
        if: env.DRY_RUN == 'true'
        working-directory: ${{ steps.map.outputs.dir }}
        run: |
          if [ "${{ github.ref_name }}" = "main" ]; then
            echo "DRY RUN: vercel pull --yes --environment=production"
          else
            echo "DRY RUN: vercel pull --yes --environment=preview --git-branch=staging"
          fi

      - name: Build Project Artifacts (LIVE)
        if: env.DRY_RUN != 'true'
        working-directory: ${{ steps.map.outputs.dir }}
        run: |
          if [ "${{ github.ref_name }}" = "main" ]; then
            vercel build --prod
          else
            vercel build
          fi

      - name: Build Project Artifacts (DRY RUN)
        if: env.DRY_RUN == 'true'
        working-directory: ${{ steps.map.outputs.dir }}
        run: |
          if [ "${{ github.ref_name }}" = "main" ]; then
            echo "DRY RUN: vercel build --prod"
          else
            echo "DRY RUN: vercel build"
          fi

      - name: Deploy Project Artifacts to Vercel (LIVE)
        if: env.DRY_RUN != 'true'
        id: deploy
        working-directory: ${{ steps.map.outputs.dir }}
        shell: bash
        run: |
          set -euo pipefail
          if [ "${{ github.ref_name }}" = "main" ]; then
            OUT=$(vercel deploy --prebuilt --prod --token=${{ secrets.VERCEL_TOKEN }} | tee /dev/stderr)
          else
            OUT=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }} | tee /dev/stderr)
          fi
          URL=$(echo "$OUT" | grep -Eo 'https?://[a-zA-Z0-9.-]+\.vercel\.app' | tail -n1 || true)
          if [ -n "$URL" ]; then
            echo "url=$URL" >> "$GITHUB_OUTPUT"
            echo "DEPLOY_URL=$URL" >> $GITHUB_ENV
          fi

      - name: Deploy Project Artifacts to Vercel (DRY RUN)
        if: env.DRY_RUN == 'true'
        working-directory: ${{ steps.map.outputs.dir }}
        run: |
          if [ "${{ github.ref_name }}" = "main" ]; then
            echo "DRY RUN: vercel deploy --prebuilt --prod"
          else
            echo "DRY RUN: vercel deploy --prebuilt"
          fi

      - name: Extract short SHA
        run: echo "SHORT_SHA=${GITHUB_SHA::7}" >> $GITHUB_ENV

      - name: Slack Notification (LIVE)
        if: always() && github.event.inputs.dry-run != true
        uses: rtCamp/action-slack-notify@v2
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          SLACK_COLOR: ${{ job.status == 'success' && 'good' || job.status == 'failure' && 'danger' || 'warning' }}
          SLACK_CUSTOM_PAYLOAD: |
            {
              "blocks": [
                { "type": "section", "text": { "type": "mrkdwn", "text": "*🚀 프론트엔드 배포 완료 알림*" } },
                { "type": "section", "text": { "type": "mrkdwn",
                  "text": "앱: *${{ env.APP_NAME }}*\n브랜치: *${{ github.ref_name }}*\n버전: *${{ env.APP_VERSION }}*(${{ env.SHORT_SHA }})\n배포 결과: *${{ job.status == 'success' && '성공' || '실패' }}*"
                  } }
              ]
            }

      - name: Slack Notification (DRY RUN)
        if: always() && github.event.inputs.dry-run == true
        run: |
          echo "⚠️ DRY RUN: Slack message would be sent with following payload:"
          cat <<'EOF'
          {
            "blocks": [
              { "type": "section", "text": { "type": "mrkdwn", "text": "*🚀 프론트엔드 배포 완료 알림*" } },
              { "type": "section", "text": { "type": "mrkdwn",
                "text": "앱: *${{ env.APP_NAME }}*\n브랜치: *${{ github.ref_name }}*\n버전: *${{ env.APP_VERSION }}*(${{ env.SHORT_SHA }})\n배포 결과: *${{ job.status == 'success' && '성공' || '실패' }}*"
                } }
            ]
          }
          EOF

      - name: Trigger QA Test Workflow (LIVE)
        if: success() && github.ref_name == 'staging' && env.DRY_RUN != 'true'
        uses: ./.github/actions/trigger-qa-test
        with:
          jenkins_url: ${{ secrets.JENKINS_URL }}
          jenkins_user: ${{ secrets.JENKINS_USER }}
          jenkins_token: ${{ secrets.JENKINS_TOKEN }}

      - name: Trigger QA Test Workflow (DRY RUN)
        if: success() && github.ref_name == 'staging' && env.DRY_RUN == 'true'
        run: |
          echo "⚠️ DRY RUN: would trigger QA workflow via Jenkins"
